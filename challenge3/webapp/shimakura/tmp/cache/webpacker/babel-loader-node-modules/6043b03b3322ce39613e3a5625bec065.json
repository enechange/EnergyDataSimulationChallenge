{"ast":null,"code":"function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n * Chartkick.js\n * Create beautiful charts with one line of JavaScript\n * https://github.com/ankane/chartkick.js\n * v3.1.1\n * MIT License\n */\n(function (global, factory) {\n  (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.Chartkick = factory());\n})(this, function () {\n  'use strict';\n\n  function isArray(variable) {\n    return Object.prototype.toString.call(variable) === \"[object Array]\";\n  }\n\n  function isFunction(variable) {\n    return variable instanceof Function;\n  }\n\n  function isPlainObject(variable) {\n    return Object.prototype.toString.call(variable) === \"[object Object]\";\n  } // https://github.com/madrobby/zepto/blob/master/src/zepto.js\n\n\n  function extend(target, source) {\n    var key;\n\n    for (key in source) {\n      if (isPlainObject(source[key]) || isArray(source[key])) {\n        if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\n          target[key] = {};\n        }\n\n        if (isArray(source[key]) && !isArray(target[key])) {\n          target[key] = [];\n        }\n\n        extend(target[key], source[key]);\n      } else if (source[key] !== undefined) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  function merge(obj1, obj2) {\n    var target = {};\n    extend(target, obj1);\n    extend(target, obj2);\n    return target;\n  }\n\n  var DATE_PATTERN = /^(\\d\\d\\d\\d)(-)?(\\d\\d)(-)?(\\d\\d)$/i; // https://github.com/Do/iso8601.js\n\n  var ISO8601_PATTERN = /(\\d\\d\\d\\d)(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)?(:)?(\\d\\d)?([.,]\\d+)?($|Z|([+-])(\\d\\d)(:)?(\\d\\d)?)/i;\n  var DECIMAL_SEPARATOR = String(1.5).charAt(1);\n\n  function parseISO8601(input) {\n    var day, hour, matches, milliseconds, minutes, month, offset, result, seconds, type, year;\n    type = Object.prototype.toString.call(input);\n\n    if (type === \"[object Date]\") {\n      return input;\n    }\n\n    if (type !== \"[object String]\") {\n      return;\n    }\n\n    matches = input.match(ISO8601_PATTERN);\n\n    if (matches) {\n      year = parseInt(matches[1], 10);\n      month = parseInt(matches[3], 10) - 1;\n      day = parseInt(matches[5], 10);\n      hour = parseInt(matches[7], 10);\n      minutes = matches[9] ? parseInt(matches[9], 10) : 0;\n      seconds = matches[11] ? parseInt(matches[11], 10) : 0;\n      milliseconds = matches[12] ? parseFloat(DECIMAL_SEPARATOR + matches[12].slice(1)) * 1000 : 0;\n      result = Date.UTC(year, month, day, hour, minutes, seconds, milliseconds);\n\n      if (matches[13] && matches[14]) {\n        offset = matches[15] * 60;\n\n        if (matches[17]) {\n          offset += parseInt(matches[17], 10);\n        }\n\n        offset *= matches[14] === \"-\" ? -1 : 1;\n        result -= offset * 60 * 1000;\n      }\n\n      return new Date(result);\n    }\n  } // end iso8601.js\n\n\n  function negativeValues(series) {\n    var i, j, data;\n\n    for (i = 0; i < series.length; i++) {\n      data = series[i].data;\n\n      for (j = 0; j < data.length; j++) {\n        if (data[j][1] < 0) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  function toStr(n) {\n    return \"\" + n;\n  }\n\n  function toFloat(n) {\n    return parseFloat(n);\n  }\n\n  function toDate(n) {\n    var matches, year, month, day;\n\n    if (_typeof(n) !== \"object\") {\n      if (typeof n === \"number\") {\n        n = new Date(n * 1000); // ms\n      } else {\n        n = toStr(n);\n\n        if (matches = n.match(DATE_PATTERN)) {\n          year = parseInt(matches[1], 10);\n          month = parseInt(matches[3], 10) - 1;\n          day = parseInt(matches[5], 10);\n          return new Date(year, month, day);\n        } else {\n          // str\n          // try our best to get the str into iso8601\n          // TODO be smarter about this\n          var str = n.replace(/ /, \"T\").replace(\" \", \"\").replace(\"UTC\", \"Z\");\n          n = parseISO8601(str) || new Date(n);\n        }\n      }\n    }\n\n    return n;\n  }\n\n  function toArr(n) {\n    if (!isArray(n)) {\n      var arr = [],\n          i;\n\n      for (i in n) {\n        if (n.hasOwnProperty(i)) {\n          arr.push([i, n[i]]);\n        }\n      }\n\n      n = arr;\n    }\n\n    return n;\n  }\n\n  function jsOptionsFunc(defaultOptions, hideLegend, setTitle, setMin, setMax, setStacked, setXtitle, setYtitle) {\n    return function (chart, opts, chartOptions) {\n      var series = chart.data;\n      var options = merge({}, defaultOptions);\n      options = merge(options, chartOptions || {});\n\n      if (chart.hideLegend || \"legend\" in opts) {\n        hideLegend(options, opts.legend, chart.hideLegend);\n      }\n\n      if (opts.title) {\n        setTitle(options, opts.title);\n      } // min\n\n\n      if (\"min\" in opts) {\n        setMin(options, opts.min);\n      } else if (!negativeValues(series)) {\n        setMin(options, 0);\n      } // max\n\n\n      if (opts.max) {\n        setMax(options, opts.max);\n      }\n\n      if (\"stacked\" in opts) {\n        setStacked(options, opts.stacked);\n      }\n\n      if (opts.colors) {\n        options.colors = opts.colors;\n      }\n\n      if (opts.xtitle) {\n        setXtitle(options, opts.xtitle);\n      }\n\n      if (opts.ytitle) {\n        setYtitle(options, opts.ytitle);\n      } // merge library last\n\n\n      options = merge(options, opts.library || {});\n      return options;\n    };\n  }\n\n  function sortByTime(a, b) {\n    return a[0].getTime() - b[0].getTime();\n  }\n\n  function sortByNumberSeries(a, b) {\n    return a[0] - b[0];\n  }\n\n  function sortByNumber(a, b) {\n    return a - b;\n  }\n\n  function isMinute(d) {\n    return d.getMilliseconds() === 0 && d.getSeconds() === 0;\n  }\n\n  function isHour(d) {\n    return isMinute(d) && d.getMinutes() === 0;\n  }\n\n  function isDay(d) {\n    return isHour(d) && d.getHours() === 0;\n  }\n\n  function isWeek(d, dayOfWeek) {\n    return isDay(d) && d.getDay() === dayOfWeek;\n  }\n\n  function isMonth(d) {\n    return isDay(d) && d.getDate() === 1;\n  }\n\n  function isYear(d) {\n    return isMonth(d) && d.getMonth() === 0;\n  }\n\n  function isDate(obj) {\n    return !isNaN(toDate(obj)) && toStr(obj).length >= 6;\n  }\n\n  function isNumber(obj) {\n    return typeof obj === \"number\";\n  }\n\n  function formatValue(pre, value, options) {\n    pre = pre || \"\";\n\n    if (options.prefix) {\n      if (value < 0) {\n        value = value * -1;\n        pre += \"-\";\n      }\n\n      pre += options.prefix;\n    }\n\n    if (options.thousands || options.decimal) {\n      value = toStr(value);\n      var parts = value.split(\".\");\n      value = parts[0];\n\n      if (options.thousands) {\n        value = value.replace(/\\B(?=(\\d{3})+(?!\\d))/g, options.thousands);\n      }\n\n      if (parts.length > 1) {\n        value += (options.decimal || \".\") + parts[1];\n      }\n    }\n\n    return pre + value + (options.suffix || \"\");\n  }\n\n  function seriesOption(chart, series, option) {\n    if (option in series) {\n      return series[option];\n    } else if (option in chart.options) {\n      return chart.options[option];\n    }\n\n    return null;\n  }\n\n  function allZeros(data) {\n    var i, j, d;\n\n    for (i = 0; i < data.length; i++) {\n      d = data[i].data;\n\n      for (j = 0; j < d.length; j++) {\n        if (d[j][1] != 0) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  var baseOptions = {\n    maintainAspectRatio: false,\n    animation: false,\n    tooltips: {\n      displayColors: false,\n      callbacks: {}\n    },\n    legend: {},\n    title: {\n      fontSize: 20,\n      fontColor: \"#333\"\n    }\n  };\n  var defaultOptions = {\n    scales: {\n      yAxes: [{\n        ticks: {\n          maxTicksLimit: 4\n        },\n        scaleLabel: {\n          fontSize: 16,\n          // fontStyle: \"bold\",\n          fontColor: \"#333\"\n        }\n      }],\n      xAxes: [{\n        gridLines: {\n          drawOnChartArea: false\n        },\n        scaleLabel: {\n          fontSize: 16,\n          // fontStyle: \"bold\",\n          fontColor: \"#333\"\n        },\n        time: {},\n        ticks: {}\n      }]\n    }\n  }; // http://there4.io/2012/05/02/google-chart-color-list/\n\n  var defaultColors = [\"#3366CC\", \"#DC3912\", \"#FF9900\", \"#109618\", \"#990099\", \"#3B3EAC\", \"#0099C6\", \"#DD4477\", \"#66AA00\", \"#B82E2E\", \"#316395\", \"#994499\", \"#22AA99\", \"#AAAA11\", \"#6633CC\", \"#E67300\", \"#8B0707\", \"#329262\", \"#5574A6\", \"#651067\"];\n\n  var hideLegend = function hideLegend(options, legend, _hideLegend) {\n    if (legend !== undefined) {\n      options.legend.display = !!legend;\n\n      if (legend && legend !== true) {\n        options.legend.position = legend;\n      }\n    } else if (_hideLegend) {\n      options.legend.display = false;\n    }\n  };\n\n  var setTitle = function setTitle(options, title) {\n    options.title.display = true;\n    options.title.text = title;\n  };\n\n  var setMin = function setMin(options, min) {\n    if (min !== null) {\n      options.scales.yAxes[0].ticks.min = toFloat(min);\n    }\n  };\n\n  var setMax = function setMax(options, max) {\n    options.scales.yAxes[0].ticks.max = toFloat(max);\n  };\n\n  var setBarMin = function setBarMin(options, min) {\n    if (min !== null) {\n      options.scales.xAxes[0].ticks.min = toFloat(min);\n    }\n  };\n\n  var setBarMax = function setBarMax(options, max) {\n    options.scales.xAxes[0].ticks.max = toFloat(max);\n  };\n\n  var setStacked = function setStacked(options, stacked) {\n    options.scales.xAxes[0].stacked = !!stacked;\n    options.scales.yAxes[0].stacked = !!stacked;\n  };\n\n  var setXtitle = function setXtitle(options, title) {\n    options.scales.xAxes[0].scaleLabel.display = true;\n    options.scales.xAxes[0].scaleLabel.labelString = title;\n  };\n\n  var setYtitle = function setYtitle(options, title) {\n    options.scales.yAxes[0].scaleLabel.display = true;\n    options.scales.yAxes[0].scaleLabel.labelString = title;\n  }; // https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\n\n\n  var addOpacity = function addOpacity(hex, opacity) {\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? \"rgba(\" + parseInt(result[1], 16) + \", \" + parseInt(result[2], 16) + \", \" + parseInt(result[3], 16) + \", \" + opacity + \")\" : hex;\n  }; // check if not null or undefined\n  // https://stackoverflow.com/a/27757708/1177228\n\n\n  var notnull = function notnull(x) {\n    return x != null;\n  };\n\n  var setLabelSize = function setLabelSize(chart, data, options) {\n    var maxLabelSize = Math.ceil(chart.element.offsetWidth / 4.0 / data.labels.length);\n\n    if (maxLabelSize > 25) {\n      maxLabelSize = 25;\n    } else if (maxLabelSize < 10) {\n      maxLabelSize = 10;\n    }\n\n    if (!options.scales.xAxes[0].ticks.callback) {\n      options.scales.xAxes[0].ticks.callback = function (value) {\n        value = toStr(value);\n\n        if (value.length > maxLabelSize) {\n          return value.substring(0, maxLabelSize - 2) + \"...\";\n        } else {\n          return value;\n        }\n      };\n    }\n  };\n\n  var setFormatOptions = function setFormatOptions(chart, options, chartType) {\n    var formatOptions = {\n      prefix: chart.options.prefix,\n      suffix: chart.options.suffix,\n      thousands: chart.options.thousands,\n      decimal: chart.options.decimal\n    };\n\n    if (chartType !== \"pie\") {\n      var myAxes = options.scales.yAxes;\n\n      if (chartType === \"bar\") {\n        myAxes = options.scales.xAxes;\n      }\n\n      if (!myAxes[0].ticks.callback) {\n        myAxes[0].ticks.callback = function (value) {\n          return formatValue(\"\", value, formatOptions);\n        };\n      }\n    }\n\n    if (!options.tooltips.callbacks.label) {\n      if (chartType === \"scatter\") {\n        options.tooltips.callbacks.label = function (item, data) {\n          var label = data.datasets[item.datasetIndex].label || '';\n\n          if (label) {\n            label += ': ';\n          }\n\n          return label + '(' + item.xLabel + ', ' + item.yLabel + ')';\n        };\n      } else if (chartType === \"bubble\") {\n        options.tooltips.callbacks.label = function (item, data) {\n          var label = data.datasets[item.datasetIndex].label || '';\n\n          if (label) {\n            label += ': ';\n          }\n\n          var dataPoint = data.datasets[item.datasetIndex].data[item.index];\n          return label + '(' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.v + ')';\n        };\n      } else if (chartType === \"pie\") {\n        // need to use separate label for pie charts\n        options.tooltips.callbacks.label = function (tooltipItem, data) {\n          var dataLabel = data.labels[tooltipItem.index];\n          var value = ': ';\n\n          if (isArray(dataLabel)) {\n            // show value on first line of multiline label\n            // need to clone because we are changing the value\n            dataLabel = dataLabel.slice();\n            dataLabel[0] += value;\n          } else {\n            dataLabel += value;\n          }\n\n          return formatValue(dataLabel, data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index], formatOptions);\n        };\n      } else {\n        var valueLabel = chartType === \"bar\" ? \"xLabel\" : \"yLabel\";\n\n        options.tooltips.callbacks.label = function (tooltipItem, data) {\n          var label = data.datasets[tooltipItem.datasetIndex].label || '';\n\n          if (label) {\n            label += ': ';\n          }\n\n          return formatValue(label, tooltipItem[valueLabel], formatOptions);\n        };\n      }\n    }\n  };\n\n  var jsOptions = jsOptionsFunc(merge(baseOptions, defaultOptions), hideLegend, setTitle, setMin, setMax, setStacked, setXtitle, setYtitle);\n\n  var createDataTable = function createDataTable(chart, options, chartType) {\n    var datasets = [];\n    var labels = [];\n    var colors = chart.options.colors || defaultColors;\n    var day = true;\n    var week = true;\n    var dayOfWeek;\n    var month = true;\n    var year = true;\n    var hour = true;\n    var minute = true;\n    var series = chart.data;\n    var max = 0;\n\n    if (chartType === \"bubble\") {\n      for (var i$1 = 0; i$1 < series.length; i$1++) {\n        var s$1 = series[i$1];\n\n        for (var j$1 = 0; j$1 < s$1.data.length; j$1++) {\n          if (s$1.data[j$1][2] > max) {\n            max = s$1.data[j$1][2];\n          }\n        }\n      }\n    }\n\n    var i,\n        j,\n        s,\n        d,\n        key,\n        rows = [],\n        rows2 = [];\n\n    if (chartType === \"bar\" || chartType === \"column\" || chart.xtype !== \"number\" && chart.xtype !== \"bubble\") {\n      var sortedLabels = [];\n\n      for (i = 0; i < series.length; i++) {\n        s = series[i];\n\n        for (j = 0; j < s.data.length; j++) {\n          d = s.data[j];\n          key = chart.xtype == \"datetime\" ? d[0].getTime() : d[0];\n\n          if (!rows[key]) {\n            rows[key] = new Array(series.length);\n          }\n\n          rows[key][i] = toFloat(d[1]);\n\n          if (sortedLabels.indexOf(key) === -1) {\n            sortedLabels.push(key);\n          }\n        }\n      }\n\n      if (chart.xtype === \"datetime\" || chart.xtype === \"number\") {\n        sortedLabels.sort(sortByNumber);\n      }\n\n      for (j = 0; j < series.length; j++) {\n        rows2.push([]);\n      }\n\n      var value;\n      var k;\n\n      for (k = 0; k < sortedLabels.length; k++) {\n        i = sortedLabels[k];\n\n        if (chart.xtype === \"datetime\") {\n          value = new Date(toFloat(i)); // TODO make this efficient\n\n          day = day && isDay(value);\n\n          if (!dayOfWeek) {\n            dayOfWeek = value.getDay();\n          }\n\n          week = week && isWeek(value, dayOfWeek);\n          month = month && isMonth(value);\n          year = year && isYear(value);\n          hour = hour && isHour(value);\n          minute = minute && isMinute(value);\n        } else {\n          value = i;\n        }\n\n        labels.push(value);\n\n        for (j = 0; j < series.length; j++) {\n          // Chart.js doesn't like undefined\n          rows2[j].push(rows[i][j] === undefined ? null : rows[i][j]);\n        }\n      }\n    } else {\n      for (var i$2 = 0; i$2 < series.length; i$2++) {\n        var s$2 = series[i$2];\n        var d$1 = [];\n\n        for (var j$2 = 0; j$2 < s$2.data.length; j$2++) {\n          var point = {\n            x: toFloat(s$2.data[j$2][0]),\n            y: toFloat(s$2.data[j$2][1])\n          };\n\n          if (chartType === \"bubble\") {\n            point.r = toFloat(s$2.data[j$2][2]) * 20 / max; // custom attribute, for tooltip\n\n            point.v = s$2.data[j$2][2];\n          }\n\n          d$1.push(point);\n        }\n\n        rows2.push(d$1);\n      }\n    }\n\n    for (i = 0; i < series.length; i++) {\n      s = series[i];\n      var color = s.color || colors[i];\n      var backgroundColor = chartType !== \"line\" ? addOpacity(color, 0.5) : color;\n      var dataset = {\n        label: s.name || \"\",\n        data: rows2[i],\n        fill: chartType === \"area\",\n        borderColor: color,\n        backgroundColor: backgroundColor,\n        pointBackgroundColor: color,\n        borderWidth: 2,\n        pointHoverBackgroundColor: color\n      };\n\n      if (s.stack) {\n        dataset.stack = s.stack;\n      }\n\n      var curve = seriesOption(chart, s, \"curve\");\n\n      if (curve === false) {\n        dataset.lineTension = 0;\n      }\n\n      var points = seriesOption(chart, s, \"points\");\n\n      if (points === false) {\n        dataset.pointRadius = 0;\n        dataset.pointHitRadius = 5;\n      }\n\n      dataset = merge(dataset, chart.options.dataset || {});\n      dataset = merge(dataset, s.library || {});\n      dataset = merge(dataset, s.dataset || {});\n      datasets.push(dataset);\n    }\n\n    var xmin = chart.options.xmin;\n    var xmax = chart.options.xmax;\n\n    if (chart.xtype === \"datetime\") {\n      if (notnull(xmin)) {\n        options.scales.xAxes[0].time.min = toDate(xmin).getTime();\n      }\n\n      if (notnull(xmax)) {\n        options.scales.xAxes[0].time.max = toDate(xmax).getTime();\n      }\n    } else if (chart.xtype === \"number\") {\n      if (notnull(xmin)) {\n        options.scales.xAxes[0].ticks.min = xmin;\n      }\n\n      if (notnull(xmax)) {\n        options.scales.xAxes[0].ticks.max = xmax;\n      }\n    }\n\n    if (chart.xtype === \"datetime\" && labels.length > 0) {\n      var minTime = (notnull(xmin) ? toDate(xmin) : labels[0]).getTime();\n      var maxTime = (notnull(xmax) ? toDate(xmax) : labels[0]).getTime();\n\n      for (i = 1; i < labels.length; i++) {\n        var value$1 = labels[i].getTime();\n\n        if (value$1 < minTime) {\n          minTime = value$1;\n        }\n\n        if (value$1 > maxTime) {\n          maxTime = value$1;\n        }\n      }\n\n      var timeDiff = (maxTime - minTime) / (86400 * 1000.0);\n\n      if (!options.scales.xAxes[0].time.unit) {\n        var step;\n\n        if (year || timeDiff > 365 * 10) {\n          options.scales.xAxes[0].time.unit = \"year\";\n          step = 365;\n        } else if (month || timeDiff > 30 * 10) {\n          options.scales.xAxes[0].time.unit = \"month\";\n          step = 30;\n        } else if (day || timeDiff > 10) {\n          options.scales.xAxes[0].time.unit = \"day\";\n          step = 1;\n        } else if (hour || timeDiff > 0.5) {\n          options.scales.xAxes[0].time.displayFormats = {\n            hour: \"MMM D, h a\"\n          };\n          options.scales.xAxes[0].time.unit = \"hour\";\n          step = 1 / 24.0;\n        } else if (minute) {\n          options.scales.xAxes[0].time.displayFormats = {\n            minute: \"h:mm a\"\n          };\n          options.scales.xAxes[0].time.unit = \"minute\";\n          step = 1 / 24.0 / 60.0;\n        }\n\n        if (step && timeDiff > 0) {\n          var unitStepSize = Math.ceil(timeDiff / step / (chart.element.offsetWidth / 100.0));\n\n          if (week && step === 1) {\n            unitStepSize = Math.ceil(unitStepSize / 7.0) * 7;\n          }\n\n          options.scales.xAxes[0].time.unitStepSize = unitStepSize;\n        }\n      }\n\n      if (!options.scales.xAxes[0].time.tooltipFormat) {\n        if (day) {\n          options.scales.xAxes[0].time.tooltipFormat = \"ll\";\n        } else if (hour) {\n          options.scales.xAxes[0].time.tooltipFormat = \"MMM D, h a\";\n        } else if (minute) {\n          options.scales.xAxes[0].time.tooltipFormat = \"h:mm a\";\n        }\n      }\n    }\n\n    var data = {\n      labels: labels,\n      datasets: datasets\n    };\n    return data;\n  };\n\n  var defaultExport = function defaultExport(library) {\n    this.name = \"chartjs\";\n    this.library = library;\n  };\n\n  defaultExport.prototype.renderLineChart = function renderLineChart(chart, chartType) {\n    var chartOptions = {}; // fix for https://github.com/chartjs/Chart.js/issues/2441\n\n    if (!chart.options.max && allZeros(chart.data)) {\n      chartOptions.max = 1;\n    }\n\n    var options = jsOptions(chart, merge(chartOptions, chart.options));\n    setFormatOptions(chart, options, chartType);\n    var data = createDataTable(chart, options, chartType || \"line\");\n\n    if (chart.xtype === \"number\") {\n      options.scales.xAxes[0].type = \"linear\";\n      options.scales.xAxes[0].position = \"bottom\";\n    } else {\n      options.scales.xAxes[0].type = chart.xtype === \"string\" ? \"category\" : \"time\";\n    }\n\n    this.drawChart(chart, \"line\", data, options);\n  };\n\n  defaultExport.prototype.renderPieChart = function renderPieChart(chart) {\n    var options = merge({}, baseOptions);\n\n    if (chart.options.donut) {\n      options.cutoutPercentage = 50;\n    }\n\n    if (\"legend\" in chart.options) {\n      hideLegend(options, chart.options.legend);\n    }\n\n    if (chart.options.title) {\n      setTitle(options, chart.options.title);\n    }\n\n    options = merge(options, chart.options.library || {});\n    setFormatOptions(chart, options, \"pie\");\n    var labels = [];\n    var values = [];\n\n    for (var i = 0; i < chart.data.length; i++) {\n      var point = chart.data[i];\n      labels.push(point[0]);\n      values.push(point[1]);\n    }\n\n    var dataset = {\n      data: values,\n      backgroundColor: chart.options.colors || defaultColors\n    };\n    dataset = merge(dataset, chart.options.dataset || {});\n    var data = {\n      labels: labels,\n      datasets: [dataset]\n    };\n    this.drawChart(chart, \"pie\", data, options);\n  };\n\n  defaultExport.prototype.renderColumnChart = function renderColumnChart(chart, chartType) {\n    var options;\n\n    if (chartType === \"bar\") {\n      var barOptions = merge(baseOptions, defaultOptions);\n      delete barOptions.scales.yAxes[0].ticks.maxTicksLimit;\n      options = jsOptionsFunc(barOptions, hideLegend, setTitle, setBarMin, setBarMax, setStacked, setXtitle, setYtitle)(chart, chart.options);\n    } else {\n      options = jsOptions(chart, chart.options);\n    }\n\n    setFormatOptions(chart, options, chartType);\n    var data = createDataTable(chart, options, \"column\");\n\n    if (chartType !== \"bar\") {\n      setLabelSize(chart, data, options);\n    }\n\n    this.drawChart(chart, chartType === \"bar\" ? \"horizontalBar\" : \"bar\", data, options);\n  };\n\n  defaultExport.prototype.renderAreaChart = function renderAreaChart(chart) {\n    this.renderLineChart(chart, \"area\");\n  };\n\n  defaultExport.prototype.renderBarChart = function renderBarChart(chart) {\n    this.renderColumnChart(chart, \"bar\");\n  };\n\n  defaultExport.prototype.renderScatterChart = function renderScatterChart(chart, chartType) {\n    chartType = chartType || \"scatter\";\n    var options = jsOptions(chart, chart.options);\n    setFormatOptions(chart, options, chartType);\n\n    if (!(\"showLines\" in options)) {\n      options.showLines = false;\n    }\n\n    var data = createDataTable(chart, options, chartType);\n    options.scales.xAxes[0].type = \"linear\";\n    options.scales.xAxes[0].position = \"bottom\";\n    this.drawChart(chart, chartType, data, options);\n  };\n\n  defaultExport.prototype.renderBubbleChart = function renderBubbleChart(chart) {\n    this.renderScatterChart(chart, \"bubble\");\n  };\n\n  defaultExport.prototype.destroy = function destroy(chart) {\n    if (chart.chart) {\n      chart.chart.destroy();\n    }\n  };\n\n  defaultExport.prototype.drawChart = function drawChart(chart, type, data, options) {\n    this.destroy(chart);\n    var chartOptions = {\n      type: type,\n      data: data,\n      options: options\n    };\n\n    if (chart.options.code) {\n      window.console.log(\"new Chart(ctx, \" + JSON.stringify(chartOptions) + \");\");\n    }\n\n    chart.element.innerHTML = \"<canvas></canvas>\";\n    var ctx = chart.element.getElementsByTagName(\"CANVAS\")[0];\n    chart.chart = new this.library(ctx, chartOptions);\n  };\n\n  var defaultOptions$1 = {\n    chart: {},\n    xAxis: {\n      title: {\n        text: null\n      },\n      labels: {\n        style: {\n          fontSize: \"12px\"\n        }\n      }\n    },\n    yAxis: {\n      title: {\n        text: null\n      },\n      labels: {\n        style: {\n          fontSize: \"12px\"\n        }\n      }\n    },\n    title: {\n      text: null\n    },\n    credits: {\n      enabled: false\n    },\n    legend: {\n      borderWidth: 0\n    },\n    tooltip: {\n      style: {\n        fontSize: \"12px\"\n      }\n    },\n    plotOptions: {\n      areaspline: {},\n      series: {\n        marker: {}\n      }\n    }\n  };\n\n  var hideLegend$1 = function hideLegend$1(options, legend, hideLegend) {\n    if (legend !== undefined) {\n      options.legend.enabled = !!legend;\n\n      if (legend && legend !== true) {\n        if (legend === \"top\" || legend === \"bottom\") {\n          options.legend.verticalAlign = legend;\n        } else {\n          options.legend.layout = \"vertical\";\n          options.legend.verticalAlign = \"middle\";\n          options.legend.align = legend;\n        }\n      }\n    } else if (hideLegend) {\n      options.legend.enabled = false;\n    }\n  };\n\n  var setTitle$1 = function setTitle$1(options, title) {\n    options.title.text = title;\n  };\n\n  var setMin$1 = function setMin$1(options, min) {\n    options.yAxis.min = min;\n  };\n\n  var setMax$1 = function setMax$1(options, max) {\n    options.yAxis.max = max;\n  };\n\n  var setStacked$1 = function setStacked$1(options, stacked) {\n    options.plotOptions.series.stacking = stacked ? stacked === true ? \"normal\" : stacked : null;\n  };\n\n  var setXtitle$1 = function setXtitle$1(options, title) {\n    options.xAxis.title.text = title;\n  };\n\n  var setYtitle$1 = function setYtitle$1(options, title) {\n    options.yAxis.title.text = title;\n  };\n\n  var jsOptions$1 = jsOptionsFunc(defaultOptions$1, hideLegend$1, setTitle$1, setMin$1, setMax$1, setStacked$1, setXtitle$1, setYtitle$1);\n\n  var setFormatOptions$1 = function setFormatOptions$1(chart, options, chartType) {\n    var formatOptions = {\n      prefix: chart.options.prefix,\n      suffix: chart.options.suffix,\n      thousands: chart.options.thousands,\n      decimal: chart.options.decimal\n    };\n\n    if (chartType !== \"pie\" && !options.yAxis.labels.formatter) {\n      options.yAxis.labels.formatter = function () {\n        return formatValue(\"\", this.value, formatOptions);\n      };\n    }\n\n    if (!options.tooltip.pointFormatter) {\n      options.tooltip.pointFormatter = function () {\n        return '<span style=\"color:' + this.color + \"\\\">\\u25CF</span> \" + formatValue(this.series.name + ': <b>', this.y, formatOptions) + '</b><br/>';\n      };\n    }\n  };\n\n  var defaultExport$1 = function defaultExport(library) {\n    this.name = \"highcharts\";\n    this.library = library;\n  };\n\n  defaultExport$1.prototype.renderLineChart = function renderLineChart(chart, chartType) {\n    chartType = chartType || \"spline\";\n    var chartOptions = {};\n\n    if (chartType === \"areaspline\") {\n      chartOptions = {\n        plotOptions: {\n          areaspline: {\n            stacking: \"normal\"\n          },\n          area: {\n            stacking: \"normal\"\n          },\n          series: {\n            marker: {\n              enabled: false\n            }\n          }\n        }\n      };\n    }\n\n    if (chart.options.curve === false) {\n      if (chartType === \"areaspline\") {\n        chartType = \"area\";\n      } else if (chartType === \"spline\") {\n        chartType = \"line\";\n      }\n    }\n\n    var options = jsOptions$1(chart, chart.options, chartOptions),\n        data,\n        i,\n        j;\n    options.xAxis.type = chart.xtype === \"string\" ? \"category\" : chart.xtype === \"number\" ? \"linear\" : \"datetime\";\n\n    if (!options.chart.type) {\n      options.chart.type = chartType;\n    }\n\n    setFormatOptions$1(chart, options, chartType);\n    var series = chart.data;\n\n    for (i = 0; i < series.length; i++) {\n      series[i].name = series[i].name || \"Value\";\n      data = series[i].data;\n\n      if (chart.xtype === \"datetime\") {\n        for (j = 0; j < data.length; j++) {\n          data[j][0] = data[j][0].getTime();\n        }\n      }\n\n      series[i].marker = {\n        symbol: \"circle\"\n      };\n\n      if (chart.options.points === false) {\n        series[i].marker.enabled = false;\n      }\n    }\n\n    this.drawChart(chart, series, options);\n  };\n\n  defaultExport$1.prototype.renderScatterChart = function renderScatterChart(chart) {\n    var options = jsOptions$1(chart, chart.options, {});\n    options.chart.type = \"scatter\";\n    this.drawChart(chart, chart.data, options);\n  };\n\n  defaultExport$1.prototype.renderPieChart = function renderPieChart(chart) {\n    var chartOptions = merge(defaultOptions$1, {});\n\n    if (chart.options.colors) {\n      chartOptions.colors = chart.options.colors;\n    }\n\n    if (chart.options.donut) {\n      chartOptions.plotOptions = {\n        pie: {\n          innerSize: \"50%\"\n        }\n      };\n    }\n\n    if (\"legend\" in chart.options) {\n      hideLegend$1(chartOptions, chart.options.legend);\n    }\n\n    if (chart.options.title) {\n      setTitle$1(chartOptions, chart.options.title);\n    }\n\n    var options = merge(chartOptions, chart.options.library || {});\n    setFormatOptions$1(chart, options, \"pie\");\n    var series = [{\n      type: \"pie\",\n      name: chart.options.label || \"Value\",\n      data: chart.data\n    }];\n    this.drawChart(chart, series, options);\n  };\n\n  defaultExport$1.prototype.renderColumnChart = function renderColumnChart(chart, chartType) {\n    chartType = chartType || \"column\";\n    var series = chart.data;\n    var options = jsOptions$1(chart, chart.options),\n        i,\n        j,\n        s,\n        d,\n        rows = [],\n        categories = [];\n    options.chart.type = chartType;\n    setFormatOptions$1(chart, options, chartType);\n\n    for (i = 0; i < series.length; i++) {\n      s = series[i];\n\n      for (j = 0; j < s.data.length; j++) {\n        d = s.data[j];\n\n        if (!rows[d[0]]) {\n          rows[d[0]] = new Array(series.length);\n          categories.push(d[0]);\n        }\n\n        rows[d[0]][i] = d[1];\n      }\n    }\n\n    if (chart.xtype === \"number\") {\n      categories.sort(sortByNumber);\n    }\n\n    options.xAxis.categories = categories;\n    var newSeries = [],\n        d2;\n\n    for (i = 0; i < series.length; i++) {\n      d = [];\n\n      for (j = 0; j < categories.length; j++) {\n        d.push(rows[categories[j]][i] || 0);\n      }\n\n      d2 = {\n        name: series[i].name || \"Value\",\n        data: d\n      };\n\n      if (series[i].stack) {\n        d2.stack = series[i].stack;\n      }\n\n      newSeries.push(d2);\n    }\n\n    this.drawChart(chart, newSeries, options);\n  };\n\n  defaultExport$1.prototype.renderBarChart = function renderBarChart(chart) {\n    this.renderColumnChart(chart, \"bar\");\n  };\n\n  defaultExport$1.prototype.renderAreaChart = function renderAreaChart(chart) {\n    this.renderLineChart(chart, \"areaspline\");\n  };\n\n  defaultExport$1.prototype.destroy = function destroy(chart) {\n    if (chart.chart) {\n      chart.chart.destroy();\n    }\n  };\n\n  defaultExport$1.prototype.drawChart = function drawChart(chart, data, options) {\n    this.destroy(chart);\n    options.chart.renderTo = chart.element.id;\n    options.series = data;\n\n    if (chart.options.code) {\n      window.console.log(\"new Highcharts.Chart(\" + JSON.stringify(options) + \");\");\n    }\n\n    chart.chart = new this.library.Chart(options);\n  };\n\n  var loaded = {};\n  var callbacks = []; // Set chart options\n\n  var defaultOptions$2 = {\n    chartArea: {},\n    fontName: \"'Lucida Grande', 'Lucida Sans Unicode', Verdana, Arial, Helvetica, sans-serif\",\n    pointSize: 6,\n    legend: {\n      textStyle: {\n        fontSize: 12,\n        color: \"#444\"\n      },\n      alignment: \"center\",\n      position: \"right\"\n    },\n    curveType: \"function\",\n    hAxis: {\n      textStyle: {\n        color: \"#666\",\n        fontSize: 12\n      },\n      titleTextStyle: {},\n      gridlines: {\n        color: \"transparent\"\n      },\n      baselineColor: \"#ccc\",\n      viewWindow: {}\n    },\n    vAxis: {\n      textStyle: {\n        color: \"#666\",\n        fontSize: 12\n      },\n      titleTextStyle: {},\n      baselineColor: \"#ccc\",\n      viewWindow: {}\n    },\n    tooltip: {\n      textStyle: {\n        color: \"#666\",\n        fontSize: 12\n      }\n    }\n  };\n\n  var hideLegend$2 = function hideLegend$2(options, legend, hideLegend) {\n    if (legend !== undefined) {\n      var position;\n\n      if (!legend) {\n        position = \"none\";\n      } else if (legend === true) {\n        position = \"right\";\n      } else {\n        position = legend;\n      }\n\n      options.legend.position = position;\n    } else if (hideLegend) {\n      options.legend.position = \"none\";\n    }\n  };\n\n  var setTitle$2 = function setTitle$2(options, title) {\n    options.title = title;\n    options.titleTextStyle = {\n      color: \"#333\",\n      fontSize: \"20px\"\n    };\n  };\n\n  var setMin$2 = function setMin$2(options, min) {\n    options.vAxis.viewWindow.min = min;\n  };\n\n  var setMax$2 = function setMax$2(options, max) {\n    options.vAxis.viewWindow.max = max;\n  };\n\n  var setBarMin$1 = function setBarMin$1(options, min) {\n    options.hAxis.viewWindow.min = min;\n  };\n\n  var setBarMax$1 = function setBarMax$1(options, max) {\n    options.hAxis.viewWindow.max = max;\n  };\n\n  var setStacked$2 = function setStacked$2(options, stacked) {\n    options.isStacked = stacked ? stacked : false;\n  };\n\n  var setXtitle$2 = function setXtitle$2(options, title) {\n    options.hAxis.title = title;\n    options.hAxis.titleTextStyle.italic = false;\n  };\n\n  var setYtitle$2 = function setYtitle$2(options, title) {\n    options.vAxis.title = title;\n    options.vAxis.titleTextStyle.italic = false;\n  };\n\n  var jsOptions$2 = jsOptionsFunc(defaultOptions$2, hideLegend$2, setTitle$2, setMin$2, setMax$2, setStacked$2, setXtitle$2, setYtitle$2);\n\n  var resize = function resize(callback) {\n    if (window.attachEvent) {\n      window.attachEvent(\"onresize\", callback);\n    } else if (window.addEventListener) {\n      window.addEventListener(\"resize\", callback, true);\n    }\n\n    callback();\n  };\n\n  var defaultExport$2 = function defaultExport(library) {\n    this.name = \"google\";\n    this.library = library;\n  };\n\n  defaultExport$2.prototype.renderLineChart = function renderLineChart(chart) {\n    var this$1 = this;\n    this.waitForLoaded(chart, function () {\n      var chartOptions = {};\n\n      if (chart.options.curve === false) {\n        chartOptions.curveType = \"none\";\n      }\n\n      if (chart.options.points === false) {\n        chartOptions.pointSize = 0;\n      }\n\n      var options = jsOptions$2(chart, chart.options, chartOptions);\n      var data = this$1.createDataTable(chart.data, chart.xtype);\n      this$1.drawChart(chart, \"LineChart\", data, options);\n    });\n  };\n\n  defaultExport$2.prototype.renderPieChart = function renderPieChart(chart) {\n    var this$1 = this;\n    this.waitForLoaded(chart, function () {\n      var chartOptions = {\n        chartArea: {\n          top: \"10%\",\n          height: \"80%\"\n        },\n        legend: {}\n      };\n\n      if (chart.options.colors) {\n        chartOptions.colors = chart.options.colors;\n      }\n\n      if (chart.options.donut) {\n        chartOptions.pieHole = 0.5;\n      }\n\n      if (\"legend\" in chart.options) {\n        hideLegend$2(chartOptions, chart.options.legend);\n      }\n\n      if (chart.options.title) {\n        setTitle$2(chartOptions, chart.options.title);\n      }\n\n      var options = merge(merge(defaultOptions$2, chartOptions), chart.options.library || {});\n      var data = new this$1.library.visualization.DataTable();\n      data.addColumn(\"string\", \"\");\n      data.addColumn(\"number\", \"Value\");\n      data.addRows(chart.data);\n      this$1.drawChart(chart, \"PieChart\", data, options);\n    });\n  };\n\n  defaultExport$2.prototype.renderColumnChart = function renderColumnChart(chart) {\n    var this$1 = this;\n    this.waitForLoaded(chart, function () {\n      var options = jsOptions$2(chart, chart.options);\n      var data = this$1.createDataTable(chart.data, chart.xtype);\n      this$1.drawChart(chart, \"ColumnChart\", data, options);\n    });\n  };\n\n  defaultExport$2.prototype.renderBarChart = function renderBarChart(chart) {\n    var this$1 = this;\n    this.waitForLoaded(chart, function () {\n      var chartOptions = {\n        hAxis: {\n          gridlines: {\n            color: \"#ccc\"\n          }\n        }\n      };\n      var options = jsOptionsFunc(defaultOptions$2, hideLegend$2, setTitle$2, setBarMin$1, setBarMax$1, setStacked$2, setXtitle$2, setYtitle$2)(chart, chart.options, chartOptions);\n      var data = this$1.createDataTable(chart.data, chart.xtype);\n      this$1.drawChart(chart, \"BarChart\", data, options);\n    });\n  };\n\n  defaultExport$2.prototype.renderAreaChart = function renderAreaChart(chart) {\n    var this$1 = this;\n    this.waitForLoaded(chart, function () {\n      var chartOptions = {\n        isStacked: true,\n        pointSize: 0,\n        areaOpacity: 0.5\n      };\n      var options = jsOptions$2(chart, chart.options, chartOptions);\n      var data = this$1.createDataTable(chart.data, chart.xtype);\n      this$1.drawChart(chart, \"AreaChart\", data, options);\n    });\n  };\n\n  defaultExport$2.prototype.renderGeoChart = function renderGeoChart(chart) {\n    var this$1 = this;\n    this.waitForLoaded(chart, function () {\n      var chartOptions = {\n        legend: \"none\",\n        colorAxis: {\n          colors: chart.options.colors || [\"#f6c7b6\", \"#ce502d\"]\n        }\n      };\n      var options = merge(merge(defaultOptions$2, chartOptions), chart.options.library || {});\n      var data = new this$1.library.visualization.DataTable();\n      data.addColumn(\"string\", \"\");\n      data.addColumn(\"number\", chart.options.label || \"Value\");\n      data.addRows(chart.data);\n      this$1.drawChart(chart, \"GeoChart\", data, options);\n    });\n  };\n\n  defaultExport$2.prototype.renderScatterChart = function renderScatterChart(chart) {\n    var this$1 = this;\n    this.waitForLoaded(chart, function () {\n      var chartOptions = {};\n      var options = jsOptions$2(chart, chart.options, chartOptions);\n      var series = chart.data,\n          rows2 = [],\n          i,\n          j,\n          data,\n          d;\n\n      for (i = 0; i < series.length; i++) {\n        series[i].name = series[i].name || \"Value\";\n        d = series[i].data;\n\n        for (j = 0; j < d.length; j++) {\n          var row = new Array(series.length + 1);\n          row[0] = d[j][0];\n          row[i + 1] = d[j][1];\n          rows2.push(row);\n        }\n      }\n\n      data = new this$1.library.visualization.DataTable();\n      data.addColumn(\"number\", \"\");\n\n      for (i = 0; i < series.length; i++) {\n        data.addColumn(\"number\", series[i].name);\n      }\n\n      data.addRows(rows2);\n      this$1.drawChart(chart, \"ScatterChart\", data, options);\n    });\n  };\n\n  defaultExport$2.prototype.renderTimeline = function renderTimeline(chart) {\n    var this$1 = this;\n    this.waitForLoaded(chart, \"timeline\", function () {\n      var chartOptions = {\n        legend: \"none\"\n      };\n\n      if (chart.options.colors) {\n        chartOptions.colors = chart.options.colors;\n      }\n\n      var options = merge(merge(defaultOptions$2, chartOptions), chart.options.library || {});\n      var data = new this$1.library.visualization.DataTable();\n      data.addColumn({\n        type: \"string\",\n        id: \"Name\"\n      });\n      data.addColumn({\n        type: \"date\",\n        id: \"Start\"\n      });\n      data.addColumn({\n        type: \"date\",\n        id: \"End\"\n      });\n      data.addRows(chart.data);\n      chart.element.style.lineHeight = \"normal\";\n      this$1.drawChart(chart, \"Timeline\", data, options);\n    });\n  };\n\n  defaultExport$2.prototype.destroy = function destroy(chart) {\n    if (chart.chart) {\n      chart.chart.clearChart();\n    }\n  };\n\n  defaultExport$2.prototype.drawChart = function drawChart(chart, type, data, options) {\n    this.destroy(chart);\n\n    if (chart.options.code) {\n      window.console.log(\"var data = new google.visualization.DataTable(\" + data.toJSON() + \");\\nvar chart = new google.visualization.\" + type + \"(element);\\nchart.draw(data, \" + JSON.stringify(options) + \");\");\n    }\n\n    chart.chart = new this.library.visualization[type](chart.element);\n    resize(function () {\n      chart.chart.draw(data, options);\n    });\n  };\n\n  defaultExport$2.prototype.waitForLoaded = function waitForLoaded(chart, pack, callback) {\n    var this$1 = this;\n\n    if (!callback) {\n      callback = pack;\n      pack = \"corechart\";\n    }\n\n    callbacks.push({\n      pack: pack,\n      callback: callback\n    });\n\n    if (loaded[pack]) {\n      this.runCallbacks();\n    } else {\n      loaded[pack] = true; // https://groups.google.com/forum/#!topic/google-visualization-api/fMKJcyA2yyI\n\n      var loadOptions = {\n        packages: [pack],\n        callback: function callback() {\n          this$1.runCallbacks();\n        }\n      };\n\n      var config = chart.__config();\n\n      if (config.language) {\n        loadOptions.language = config.language;\n      }\n\n      if (pack === \"corechart\" && config.mapsApiKey) {\n        loadOptions.mapsApiKey = config.mapsApiKey;\n      }\n\n      this.library.charts.load(\"current\", loadOptions);\n    }\n  };\n\n  defaultExport$2.prototype.runCallbacks = function runCallbacks() {\n    var cb, call;\n\n    for (var i = 0; i < callbacks.length; i++) {\n      cb = callbacks[i];\n      call = this.library.visualization && (cb.pack === \"corechart\" && this.library.visualization.LineChart || cb.pack === \"timeline\" && this.library.visualization.Timeline);\n\n      if (call) {\n        cb.callback();\n        callbacks.splice(i, 1);\n        i--;\n      }\n    }\n  }; // cant use object as key\n\n\n  defaultExport$2.prototype.createDataTable = function createDataTable(series, columnType) {\n    var i,\n        j,\n        s,\n        d,\n        key,\n        rows = [],\n        sortedLabels = [];\n\n    for (i = 0; i < series.length; i++) {\n      s = series[i];\n      series[i].name = series[i].name || \"Value\";\n\n      for (j = 0; j < s.data.length; j++) {\n        d = s.data[j];\n        key = columnType === \"datetime\" ? d[0].getTime() : d[0];\n\n        if (!rows[key]) {\n          rows[key] = new Array(series.length);\n          sortedLabels.push(key);\n        }\n\n        rows[key][i] = toFloat(d[1]);\n      }\n    }\n\n    var rows2 = [];\n    var day = true;\n    var value;\n\n    for (j = 0; j < sortedLabels.length; j++) {\n      i = sortedLabels[j];\n\n      if (columnType === \"datetime\") {\n        value = new Date(toFloat(i));\n        day = day && isDay(value);\n      } else if (columnType === \"number\") {\n        value = toFloat(i);\n      } else {\n        value = i;\n      }\n\n      rows2.push([value].concat(rows[i]));\n    }\n\n    if (columnType === \"datetime\") {\n      rows2.sort(sortByTime);\n    } else if (columnType === \"number\") {\n      rows2.sort(sortByNumberSeries);\n\n      for (i = 0; i < rows2.length; i++) {\n        rows2[i][0] = toStr(rows2[i][0]);\n      }\n\n      columnType = \"string\";\n    } // create datatable\n\n\n    var data = new this.library.visualization.DataTable();\n    columnType = columnType === \"datetime\" && day ? \"date\" : columnType;\n    data.addColumn(columnType, \"\");\n\n    for (i = 0; i < series.length; i++) {\n      data.addColumn(\"number\", series[i].name);\n    }\n\n    data.addRows(rows2);\n    return data;\n  };\n\n  var pendingRequests = [],\n      runningRequests = 0,\n      maxRequests = 4;\n\n  function pushRequest(url, success, error) {\n    pendingRequests.push([url, success, error]);\n    runNext();\n  }\n\n  function runNext() {\n    if (runningRequests < maxRequests) {\n      var request = pendingRequests.shift();\n\n      if (request) {\n        runningRequests++;\n        getJSON(request[0], request[1], request[2]);\n        runNext();\n      }\n    }\n  }\n\n  function requestComplete() {\n    runningRequests--;\n    runNext();\n  }\n\n  function getJSON(url, success, error) {\n    ajaxCall(url, success, function (jqXHR, textStatus, errorThrown) {\n      var message = typeof errorThrown === \"string\" ? errorThrown : errorThrown.message;\n      error(message);\n    });\n  }\n\n  function ajaxCall(url, success, error) {\n    var $ = window.jQuery || window.Zepto || window.$;\n\n    if ($) {\n      $.ajax({\n        dataType: \"json\",\n        url: url,\n        success: success,\n        error: error,\n        complete: requestComplete\n      });\n    } else {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", url, true);\n      xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n\n      xhr.onload = function () {\n        requestComplete();\n\n        if (xhr.status === 200) {\n          success(JSON.parse(xhr.responseText), xhr.statusText, xhr);\n        } else {\n          error(xhr, \"error\", xhr.statusText);\n        }\n      };\n\n      xhr.send();\n    }\n  }\n\n  var config = {};\n  var adapters = []; // helpers\n\n  function setText(element, text) {\n    if (document.body.innerText) {\n      element.innerText = text;\n    } else {\n      element.textContent = text;\n    }\n  }\n\n  function chartError(element, message) {\n    setText(element, \"Error Loading Chart: \" + message);\n    element.style.color = \"#ff0000\";\n  }\n\n  function errorCatcher(chart) {\n    try {\n      chart.__render();\n    } catch (err) {\n      chartError(chart.element, err.message);\n      throw err;\n    }\n  }\n\n  function fetchDataSource(chart, dataSource) {\n    if (typeof dataSource === \"string\") {\n      pushRequest(dataSource, function (data) {\n        chart.rawData = data;\n        errorCatcher(chart);\n      }, function (message) {\n        chartError(chart.element, message);\n      });\n    } else {\n      chart.rawData = dataSource;\n      errorCatcher(chart);\n    }\n  }\n\n  function addDownloadButton(chart) {\n    var element = chart.element;\n    var link = document.createElement(\"a\");\n    var download = chart.options.download;\n\n    if (download === true) {\n      download = {};\n    } else if (typeof download === \"string\") {\n      download = {\n        filename: download\n      };\n    }\n\n    link.download = download.filename || \"chart.png\"; // https://caniuse.com/download\n\n    link.style.position = \"absolute\";\n    link.style.top = \"20px\";\n    link.style.right = \"20px\";\n    link.style.zIndex = 1000;\n    link.style.lineHeight = \"20px\";\n    link.target = \"_blank\"; // for safari\n\n    var image = document.createElement(\"img\");\n    image.alt = \"Download\";\n    image.style.border = \"none\"; // icon from font-awesome\n    // http://fa2png.io/\n\n    image.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAABCFBMVEUAAADMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMywEsqxAAAAV3RSTlMAAQIDBggJCgsMDQ4PERQaHB0eISIjJCouLzE0OTo/QUJHSUpLTU5PUllhYmltcHh5foWLjI+SlaCio6atr7S1t7m6vsHHyM7R2tze5Obo7fHz9ff5+/1hlxK2AAAA30lEQVQYGUXBhVYCQQBA0TdYWAt2d3d3YWAHyur7/z9xgD16Lw0DW+XKx+1GgX+FRzM3HWQWrHl5N/oapW5RPe0PkBu+UYeICvozTWZVK23Ao04B79oJrOsJDOoxkZoQPWgX29pHpCZEk7rEvQYiNSFq1UMqvlCjJkRBS1R8hb00Vb/TajtBL7nTHE1X1vyMQF732dQhyF2o6SAwrzP06iUQzvwsArlnzcOdrgBhJyHa1QOgO9U1GsKuvjUTjavliZYQ8nNPapG6sap/3nrIdJ6bOWzmX/fy0XVpfzZP3S8OJT3g9EEiJwAAAABJRU5ErkJggg==\";\n    link.appendChild(image);\n    element.style.position = \"relative\";\n    chart.__downloadAttached = true; // mouseenter\n\n    chart.__enterEvent = addEvent(element, \"mouseover\", function (e) {\n      var related = e.relatedTarget; // check download option again to ensure it wasn't changed\n\n      if ((!related || related !== this && !childOf(this, related)) && chart.options.download) {\n        link.href = chart.toImage(download);\n        element.appendChild(link);\n      }\n    }); // mouseleave\n\n    chart.__leaveEvent = addEvent(element, \"mouseout\", function (e) {\n      var related = e.relatedTarget;\n\n      if (!related || related !== this && !childOf(this, related)) {\n        if (link.parentNode) {\n          link.parentNode.removeChild(link);\n        }\n      }\n    });\n  } // https://stackoverflow.com/questions/10149963/adding-event-listener-cross-browser\n\n\n  function addEvent(elem, event, fn) {\n    if (elem.addEventListener) {\n      elem.addEventListener(event, fn, false);\n      return fn;\n    } else {\n      var fn2 = function fn2() {\n        // set the this pointer same as addEventListener when fn is called\n        return fn.call(elem, window.event);\n      };\n\n      elem.attachEvent(\"on\" + event, fn2);\n      return fn2;\n    }\n  }\n\n  function removeEvent(elem, event, fn) {\n    if (elem.removeEventListener) {\n      elem.removeEventListener(event, fn, false);\n    } else {\n      elem.detachEvent(\"on\" + event, fn);\n    }\n  } // https://gist.github.com/shawnbot/4166283\n\n\n  function childOf(p, c) {\n    if (p === c) {\n      return false;\n    }\n\n    while (c && c !== p) {\n      c = c.parentNode;\n    }\n\n    return c === p;\n  }\n\n  function getAdapterType(library) {\n    if (library) {\n      if (library.product === \"Highcharts\") {\n        return defaultExport$1;\n      } else if (library.charts) {\n        return defaultExport$2;\n      } else if (isFunction(library)) {\n        return defaultExport;\n      }\n    }\n\n    throw new Error(\"Unknown adapter\");\n  }\n\n  function addAdapter(library) {\n    var adapterType = getAdapterType(library);\n    var adapter = new adapterType(library);\n\n    if (adapters.indexOf(adapter) === -1) {\n      adapters.push(adapter);\n    }\n  }\n\n  function loadAdapters() {\n    if (\"Chart\" in window) {\n      addAdapter(window.Chart);\n    }\n\n    if (\"Highcharts\" in window) {\n      addAdapter(window.Highcharts);\n    }\n\n    if (window.google && window.google.charts) {\n      addAdapter(window.google);\n    }\n  }\n\n  function dataEmpty(data, chartType) {\n    if (chartType === \"PieChart\" || chartType === \"GeoChart\" || chartType === \"Timeline\") {\n      return data.length === 0;\n    } else {\n      for (var i = 0; i < data.length; i++) {\n        if (data[i].data.length > 0) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  function renderChart(chartType, chart) {\n    if (chart.options.messages && chart.options.messages.empty && dataEmpty(chart.data, chartType)) {\n      setText(chart.element, chart.options.messages.empty);\n    } else {\n      callAdapter(chartType, chart);\n\n      if (chart.options.download && !chart.__downloadAttached && chart.adapter === \"chartjs\") {\n        addDownloadButton(chart);\n      }\n    }\n  } // TODO remove chartType if cross-browser way\n  // to get the name of the chart class\n\n\n  function callAdapter(chartType, chart) {\n    var i, adapter, fnName, adapterName;\n    fnName = \"render\" + chartType;\n    adapterName = chart.options.adapter;\n    loadAdapters();\n\n    for (i = 0; i < adapters.length; i++) {\n      adapter = adapters[i];\n\n      if ((!adapterName || adapterName === adapter.name) && isFunction(adapter[fnName])) {\n        chart.adapter = adapter.name;\n        chart.__adapterObject = adapter;\n        return adapter[fnName](chart);\n      }\n    }\n\n    if (adapters.length > 0) {\n      throw new Error(\"No charting library found for \" + chartType);\n    } else {\n      throw new Error(\"No charting libraries found - be sure to include one before your charts\");\n    }\n  } // process data\n\n\n  var toFormattedKey = function toFormattedKey(key, keyType) {\n    if (keyType === \"number\") {\n      key = toFloat(key);\n    } else if (keyType === \"datetime\") {\n      key = toDate(key);\n    } else {\n      key = toStr(key);\n    }\n\n    return key;\n  };\n\n  var formatSeriesData = function formatSeriesData(data, keyType) {\n    var r = [],\n        key,\n        j;\n\n    for (j = 0; j < data.length; j++) {\n      if (keyType === \"bubble\") {\n        r.push([toFloat(data[j][0]), toFloat(data[j][1]), toFloat(data[j][2])]);\n      } else {\n        key = toFormattedKey(data[j][0], keyType);\n        r.push([key, toFloat(data[j][1])]);\n      }\n    }\n\n    if (keyType === \"datetime\") {\n      r.sort(sortByTime);\n    } else if (keyType === \"number\") {\n      r.sort(sortByNumberSeries);\n    }\n\n    return r;\n  };\n\n  function detectXType(series, noDatetime) {\n    if (detectXTypeWithFunction(series, isNumber)) {\n      return \"number\";\n    } else if (!noDatetime && detectXTypeWithFunction(series, isDate)) {\n      return \"datetime\";\n    } else {\n      return \"string\";\n    }\n  }\n\n  function detectXTypeWithFunction(series, func) {\n    var i, j, data;\n\n    for (i = 0; i < series.length; i++) {\n      data = toArr(series[i].data);\n\n      for (j = 0; j < data.length; j++) {\n        if (!func(data[j][0])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  } // creates a shallow copy of each element of the array\n  // elements are expected to be objects\n\n\n  function copySeries(series) {\n    var newSeries = [],\n        i,\n        j;\n\n    for (i = 0; i < series.length; i++) {\n      var copy = {};\n\n      for (j in series[i]) {\n        if (series[i].hasOwnProperty(j)) {\n          copy[j] = series[i][j];\n        }\n      }\n\n      newSeries.push(copy);\n    }\n\n    return newSeries;\n  }\n\n  function processSeries(chart, keyType, noDatetime) {\n    var i;\n    var opts = chart.options;\n    var series = chart.rawData; // see if one series or multiple\n\n    if (!isArray(series) || _typeof(series[0]) !== \"object\" || isArray(series[0])) {\n      series = [{\n        name: opts.label,\n        data: series\n      }];\n      chart.hideLegend = true;\n    } else {\n      chart.hideLegend = false;\n    }\n\n    chart.xtype = keyType ? keyType : opts.discrete ? \"string\" : detectXType(series, noDatetime); // right format\n\n    series = copySeries(series);\n\n    for (i = 0; i < series.length; i++) {\n      series[i].data = formatSeriesData(toArr(series[i].data), chart.xtype);\n    }\n\n    return series;\n  }\n\n  function processSimple(chart) {\n    var perfectData = toArr(chart.rawData),\n        i;\n\n    for (i = 0; i < perfectData.length; i++) {\n      perfectData[i] = [toStr(perfectData[i][0]), toFloat(perfectData[i][1])];\n    }\n\n    return perfectData;\n  } // define classes\n\n\n  var Chart = function Chart(element, dataSource, options) {\n    var elementId;\n\n    if (typeof element === \"string\") {\n      elementId = element;\n      element = document.getElementById(element);\n\n      if (!element) {\n        throw new Error(\"No element with id \" + elementId);\n      }\n    }\n\n    this.element = element;\n    this.options = merge(Chartkick.options, options || {});\n    this.dataSource = dataSource;\n    Chartkick.charts[element.id] = this;\n    fetchDataSource(this, dataSource);\n\n    if (this.options.refresh) {\n      this.startRefresh();\n    }\n  };\n\n  Chart.prototype.getElement = function getElement() {\n    return this.element;\n  };\n\n  Chart.prototype.getDataSource = function getDataSource() {\n    return this.dataSource;\n  };\n\n  Chart.prototype.getData = function getData() {\n    return this.data;\n  };\n\n  Chart.prototype.getOptions = function getOptions() {\n    return this.options;\n  };\n\n  Chart.prototype.getChartObject = function getChartObject() {\n    return this.chart;\n  };\n\n  Chart.prototype.getAdapter = function getAdapter() {\n    return this.adapter;\n  };\n\n  Chart.prototype.updateData = function updateData(dataSource, options) {\n    this.dataSource = dataSource;\n\n    if (options) {\n      this.__updateOptions(options);\n    }\n\n    fetchDataSource(this, dataSource);\n  };\n\n  Chart.prototype.setOptions = function setOptions(options) {\n    this.__updateOptions(options);\n\n    this.redraw();\n  };\n\n  Chart.prototype.redraw = function redraw() {\n    fetchDataSource(this, this.rawData);\n  };\n\n  Chart.prototype.refreshData = function refreshData() {\n    if (typeof this.dataSource === \"string\") {\n      // prevent browser from caching\n      var sep = this.dataSource.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n      var url = this.dataSource + sep + \"_=\" + new Date().getTime();\n      fetchDataSource(this, url);\n    }\n  };\n\n  Chart.prototype.startRefresh = function startRefresh() {\n    var this$1 = this;\n    var refresh = this.options.refresh;\n\n    if (refresh && typeof this.dataSource !== \"string\") {\n      throw new Error(\"Data source must be a URL for refresh\");\n    }\n\n    if (!this.intervalId) {\n      if (refresh) {\n        this.intervalId = setInterval(function () {\n          this$1.refreshData();\n        }, refresh * 1000);\n      } else {\n        throw new Error(\"No refresh interval\");\n      }\n    }\n  };\n\n  Chart.prototype.stopRefresh = function stopRefresh() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n  };\n\n  Chart.prototype.toImage = function toImage(download) {\n    if (this.adapter === \"chartjs\") {\n      if (download && download.background && download.background !== \"transparent\") {\n        // https://stackoverflow.com/questions/30464750/chartjs-line-chart-set-background-color\n        var canvas = this.chart.chart.canvas;\n        var ctx = this.chart.chart.ctx;\n        var tmpCanvas = document.createElement(\"canvas\");\n        var tmpCtx = tmpCanvas.getContext(\"2d\");\n        tmpCanvas.width = ctx.canvas.width;\n        tmpCanvas.height = ctx.canvas.height;\n        tmpCtx.fillStyle = download.background;\n        tmpCtx.fillRect(0, 0, tmpCanvas.width, tmpCanvas.height);\n        tmpCtx.drawImage(canvas, 0, 0);\n        return tmpCanvas.toDataURL(\"image/png\");\n      } else {\n        return this.chart.toBase64Image();\n      }\n    } else {\n      // TODO throw error in next major version\n      // throw new Error(\"Feature only available for Chart.js\");\n      return null;\n    }\n  };\n\n  Chart.prototype.destroy = function destroy() {\n    if (this.__adapterObject) {\n      this.__adapterObject.destroy(this);\n    }\n\n    if (this.__enterEvent) {\n      removeEvent(this.element, \"mouseover\", this.__enterEvent);\n    }\n\n    if (this.__leaveEvent) {\n      removeEvent(this.element, \"mouseout\", this.__leaveEvent);\n    }\n  };\n\n  Chart.prototype.__updateOptions = function __updateOptions(options) {\n    var updateRefresh = options.refresh && options.refresh !== this.options.refresh;\n    this.options = merge(Chartkick.options, options);\n\n    if (updateRefresh) {\n      this.stopRefresh();\n      this.startRefresh();\n    }\n  };\n\n  Chart.prototype.__render = function __render() {\n    this.data = this.__processData();\n    renderChart(this.__chartName(), this);\n  };\n\n  Chart.prototype.__config = function __config() {\n    return config;\n  };\n\n  var LineChart =\n  /*@__PURE__*/\n  function (Chart) {\n    function LineChart() {\n      Chart.apply(this, arguments);\n    }\n\n    if (Chart) LineChart.__proto__ = Chart;\n    LineChart.prototype = Object.create(Chart && Chart.prototype);\n    LineChart.prototype.constructor = LineChart;\n\n    LineChart.prototype.__processData = function __processData() {\n      return processSeries(this);\n    };\n\n    LineChart.prototype.__chartName = function __chartName() {\n      return \"LineChart\";\n    };\n\n    return LineChart;\n  }(Chart);\n\n  var PieChart =\n  /*@__PURE__*/\n  function (Chart) {\n    function PieChart() {\n      Chart.apply(this, arguments);\n    }\n\n    if (Chart) PieChart.__proto__ = Chart;\n    PieChart.prototype = Object.create(Chart && Chart.prototype);\n    PieChart.prototype.constructor = PieChart;\n\n    PieChart.prototype.__processData = function __processData() {\n      return processSimple(this);\n    };\n\n    PieChart.prototype.__chartName = function __chartName() {\n      return \"PieChart\";\n    };\n\n    return PieChart;\n  }(Chart);\n\n  var ColumnChart =\n  /*@__PURE__*/\n  function (Chart) {\n    function ColumnChart() {\n      Chart.apply(this, arguments);\n    }\n\n    if (Chart) ColumnChart.__proto__ = Chart;\n    ColumnChart.prototype = Object.create(Chart && Chart.prototype);\n    ColumnChart.prototype.constructor = ColumnChart;\n\n    ColumnChart.prototype.__processData = function __processData() {\n      return processSeries(this, null, true);\n    };\n\n    ColumnChart.prototype.__chartName = function __chartName() {\n      return \"ColumnChart\";\n    };\n\n    return ColumnChart;\n  }(Chart);\n\n  var BarChart =\n  /*@__PURE__*/\n  function (Chart) {\n    function BarChart() {\n      Chart.apply(this, arguments);\n    }\n\n    if (Chart) BarChart.__proto__ = Chart;\n    BarChart.prototype = Object.create(Chart && Chart.prototype);\n    BarChart.prototype.constructor = BarChart;\n\n    BarChart.prototype.__processData = function __processData() {\n      return processSeries(this, null, true);\n    };\n\n    BarChart.prototype.__chartName = function __chartName() {\n      return \"BarChart\";\n    };\n\n    return BarChart;\n  }(Chart);\n\n  var AreaChart =\n  /*@__PURE__*/\n  function (Chart) {\n    function AreaChart() {\n      Chart.apply(this, arguments);\n    }\n\n    if (Chart) AreaChart.__proto__ = Chart;\n    AreaChart.prototype = Object.create(Chart && Chart.prototype);\n    AreaChart.prototype.constructor = AreaChart;\n\n    AreaChart.prototype.__processData = function __processData() {\n      return processSeries(this);\n    };\n\n    AreaChart.prototype.__chartName = function __chartName() {\n      return \"AreaChart\";\n    };\n\n    return AreaChart;\n  }(Chart);\n\n  var GeoChart =\n  /*@__PURE__*/\n  function (Chart) {\n    function GeoChart() {\n      Chart.apply(this, arguments);\n    }\n\n    if (Chart) GeoChart.__proto__ = Chart;\n    GeoChart.prototype = Object.create(Chart && Chart.prototype);\n    GeoChart.prototype.constructor = GeoChart;\n\n    GeoChart.prototype.__processData = function __processData() {\n      return processSimple(this);\n    };\n\n    GeoChart.prototype.__chartName = function __chartName() {\n      return \"GeoChart\";\n    };\n\n    return GeoChart;\n  }(Chart);\n\n  var ScatterChart =\n  /*@__PURE__*/\n  function (Chart) {\n    function ScatterChart() {\n      Chart.apply(this, arguments);\n    }\n\n    if (Chart) ScatterChart.__proto__ = Chart;\n    ScatterChart.prototype = Object.create(Chart && Chart.prototype);\n    ScatterChart.prototype.constructor = ScatterChart;\n\n    ScatterChart.prototype.__processData = function __processData() {\n      return processSeries(this, \"number\");\n    };\n\n    ScatterChart.prototype.__chartName = function __chartName() {\n      return \"ScatterChart\";\n    };\n\n    return ScatterChart;\n  }(Chart);\n\n  var BubbleChart =\n  /*@__PURE__*/\n  function (Chart) {\n    function BubbleChart() {\n      Chart.apply(this, arguments);\n    }\n\n    if (Chart) BubbleChart.__proto__ = Chart;\n    BubbleChart.prototype = Object.create(Chart && Chart.prototype);\n    BubbleChart.prototype.constructor = BubbleChart;\n\n    BubbleChart.prototype.__processData = function __processData() {\n      return processSeries(this, \"bubble\");\n    };\n\n    BubbleChart.prototype.__chartName = function __chartName() {\n      return \"BubbleChart\";\n    };\n\n    return BubbleChart;\n  }(Chart);\n\n  var Timeline =\n  /*@__PURE__*/\n  function (Chart) {\n    function Timeline() {\n      Chart.apply(this, arguments);\n    }\n\n    if (Chart) Timeline.__proto__ = Chart;\n    Timeline.prototype = Object.create(Chart && Chart.prototype);\n    Timeline.prototype.constructor = Timeline;\n\n    Timeline.prototype.__processData = function __processData() {\n      var i,\n          data = this.rawData;\n\n      for (i = 0; i < data.length; i++) {\n        data[i][1] = toDate(data[i][1]);\n        data[i][2] = toDate(data[i][2]);\n      }\n\n      return data;\n    };\n\n    Timeline.prototype.__chartName = function __chartName() {\n      return \"Timeline\";\n    };\n\n    return Timeline;\n  }(Chart);\n\n  var Chartkick = {\n    LineChart: LineChart,\n    PieChart: PieChart,\n    ColumnChart: ColumnChart,\n    BarChart: BarChart,\n    AreaChart: AreaChart,\n    GeoChart: GeoChart,\n    ScatterChart: ScatterChart,\n    BubbleChart: BubbleChart,\n    Timeline: Timeline,\n    charts: {},\n    configure: function configure(options) {\n      for (var key in options) {\n        if (options.hasOwnProperty(key)) {\n          config[key] = options[key];\n        }\n      }\n    },\n    setDefaultOptions: function setDefaultOptions(opts) {\n      Chartkick.options = opts;\n    },\n    eachChart: function eachChart(callback) {\n      for (var chartId in Chartkick.charts) {\n        if (Chartkick.charts.hasOwnProperty(chartId)) {\n          callback(Chartkick.charts[chartId]);\n        }\n      }\n    },\n    config: config,\n    options: {},\n    adapters: adapters,\n    addAdapter: addAdapter,\n    use: function use(adapter) {\n      addAdapter(adapter);\n      return Chartkick;\n    }\n  }; // not ideal, but allows for simpler integration\n\n  if (typeof window !== \"undefined\" && !window.Chartkick) {\n    window.Chartkick = Chartkick;\n  } // backwards compatibility for esm require\n\n\n  Chartkick[\"default\"] = Chartkick;\n  return Chartkick;\n});","map":null,"metadata":{},"sourceType":"module"}